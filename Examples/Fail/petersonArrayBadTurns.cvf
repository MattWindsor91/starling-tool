/*
 * Peterson's algorithm for mutual exclusion:
 * http://dx.doi.org/10.1016/0020-0190(81)90106-X
 *
 * This version uses a flag array, and is purposely broken.
 *
 * This proof was manually written: future exercises could involve
 * making it easier to synthesise parts of it.
 */


shared bool[2] flag;    // Status of the two threads' claims to the lock.
shared int turn;        // Whichever thread locked most recently has this.

thread bool oFlag;      // The thread's view of its opponent's flag state.
thread int oTurn;       // The thread's view of the current turn.
thread int i;           // The thread's turn identifier.

view FlagDown(int me);  // 'me' does not hold the lock and is not seeking it.
view FlagUp(int me);    // 'me' has put its flag up, but isn't waiting yet.
view Waiting(int me);   // 'me' is now waiting for the lock.
view HoldLock(int me);  // 'me' holds the lock.


/*
 * Locks the Peterson lock.
 */
method lock() {
  {| FlagDown(i) |}
    <| flag[i] = true; |>
  {| FlagUp(i) |}
    <| turn = (i + 1) % 2; |> // oops!
  {| Waiting(i) |}
    do {
      {| Waiting(i) |}
        <| oFlag = flag[(i + 1) % 2]; |>
      {| if oFlag { Waiting(i) } else { HoldLock(i) } |}
        <| oTurn = turn; |>
      {| if oFlag && (oTurn == i) { Waiting(i) } else { HoldLock(i) } |}
    } while oFlag && (oTurn == i);
  {| HoldLock(i) |}
}

/*
 * Unlocks the Peterson lock.
 */
method unlock() {
  {| HoldLock(i) |}
    <| flag[i] = false; |>
  {| FlagDown(i) |}
}

// Invariant: turn is always something well-formed.
constraint emp -> (turn == 0 || turn == 1);

/*
 * Predicate definitions.
 *
 * Most of the interesting work happens in the interactions between
 * constraints: these just keep track of the flag and ensure 'me' is valid.
 */
constraint FlagDown(me)      -> flag[me] == false && (me == 0 || me == 1);
constraint FlagUp(me)        -> flag[me] == true  && (me == 0 || me == 1);
constraint Waiting(me)       -> flag[me] == true  && (me == 0 || me == 1);
constraint HoldLock(me)      -> flag[me] == true  && (me == 0 || me == 1);

/*
 * If we have the lock, and the other thread is waiting, we have the turn.
 * Also, we cannot be holding and waiting at the same time.
 *
 * We note that to get the lock we must have either seen
 * the other thread's flag down (see above), or we must have already
 * been given the turn.
 *
 * More directly (and closer to how Starling will be proving this),
 * any transition where the other thread starts waiting sets the turn
 * to our turn, and nothing destabilises this except us starting to
 * wait too.
 */
constraint HoldLock(me) * Waiting(you) -> me != you && turn == you;

/*
 * We can't be in multiple states at the same time, unless exactly one of those
 * states is flag-down.
 */
constraint FlagDown(me) * FlagDown(you) -> me != you;
constraint FlagUp(me)   * FlagUp(you)   -> me != you;
constraint FlagUp(me)   * Waiting(you)  -> me != you;
constraint FlagUp(me)   * HoldLock(you) -> me != you;
constraint Waiting(me)  * Waiting(you)  -> me != you;

/*
 * Goal: mutual exclusion.
 */
constraint HoldLock(me) * HoldLock(you) -> false;
