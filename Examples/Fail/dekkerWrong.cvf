/*
 * The unsafe second attempt of Dekker's algorithm from Ben-Ari's
 * 'Principles of Concurrent Programming', first edition.
 */

shared bool[2] want;

method lock(int tid)
{
    {| Idle(tid) |}
        thread bool other_wants;
        do {
            {| Idle(tid) |}
                <| other_wants = want[(tid + 1)% 2]; |>
            {| if other_wants { Idle(tid) } else { Want(tid) } |}
        } while other_wants;
    {| Want(tid) |}
         <| want[tid] = true; |>
    {| HoldLock(tid) |}
}

method unlock(int tid)
{
    {| HoldLock(tid) |}
        <| want[tid] = false; |>
    {| Idle(tid) |}
}

view Idle(int tid), Want(int tid), HoldLock(int tid);

constraint Idle(tid)         -> (tid == 0 || tid == 1) && !want[tid];
constraint Want(tid)         -> (tid == 0 || tid == 1) && !want[tid]
                                && !want[(tid + 1)% 2];
constraint HoldLock(tid)     -> (tid == 0 || tid == 1) &&  want[tid];

constraint HoldLock(x)     * HoldLock(y) -> false;

constraint Idle(x)         * Idle(y)         -> x != y;
constraint Idle(x)         * Want(y)         -> x != y;
constraint Idle(x)         * HoldLock(y)     -> x != y;
constraint Want(x)         * Want(y)         -> false;
constraint Want(x)         * HoldLock(y)     -> x != y;
